// Class: ReadBDT_VBF0HighPt
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT_VBF0HighPt
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.10/09       [395785]
Creator        : ajafari
Date           : Fri Nov 30 14:54:58 2018
Host           : Linux cmsbuild49.cern.ch 2.6.32-696.10.2.el6.x86_64 #1 SMP Thu Sep 14 16:35:02 CEST 2017 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /afs/cern.ch/work/a/ajafari/Vjj/CMSSW_9_4_2/src/TopLJets2015/TopAnalysis/macro
Training events: 53276
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "True" [Create PDFs for classifier outputs (signal and background)]
nCuts: "0" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "6.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "4" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 17
mjj                           mjj                           mjj                           mjj                                                             'F'    [500.007110596,8966.10839844]
jjpt                          jjpt                          jjpt                          jjpt                                                            'F'    [4.85194396973,1512.05419922]
detajj                        detajj                        detajj                        detajj                                                          'F'    [0.000106394290924,7.99623584747]
dphijj                        dphijj                        dphijj                        dphijj                                                          'F'    [-3.14156651497,3.14158058167]
ystar                         ystar                         ystar                         ystar                                                           'F'    [-4.43096017838,4.6264090538]
relbpt                        relbpt                        relbpt                        relbpt                                                          'F'    [0.296877026558,15.4000034332]
dphibjj                       dphibjj                       dphibjj                       dphibjj                                                         'F'    [-3.14158630371,3.14158272743]
balance                       balance                       balance                       balance                                                         'F'    [0.268257379532,998.726013184]
j_c2_00[0]                    j_c2_00_0_                    j_c2_00[0]                    jet_c2_001                                                      'F'    [-1,0.646148145199]
j_c2_00[1]                    j_c2_00_1_                    j_c2_00[1]                    jet_c2_002                                                      'F'    [-1,0.648723065853]
j_qg[0]                       j_qg_0_                       j_qg[0]                       leadjet_qg                                                      'F'    [-1,1]
j_qg[1]                       j_qg_1_                       j_qg[1]                       subleadjet_qg                                                   'F'    [-1,1]
dphivj1                       dphivj1                       dphivj1                       dphivj1                                                         'F'    [0.000400245189667,3.14157629013]
dphivj2                       dphivj2                       dphivj2                       dphivj2                                                         'F'    [9.10609960556e-05,9999]
ht                            ht                            ht                            ht                                                              'F'    [96.3584747314,3740.47631836]
isotropy                      isotropy                      isotropy                      isotropy                                                        'F'    [0.14432567358,0.998565673828]
D                             D                             D                             D                                                               'F'    [2.18279756249e-12,0.941354632378]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDT_VBF0HighPtNode
   
#ifndef BDT_VBF0HighPtNode__def
#define BDT_VBF0HighPtNode__def
   
class BDT_VBF0HighPtNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDT_VBF0HighPtNode ( BDT_VBF0HighPtNode* left,BDT_VBF0HighPtNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDT_VBF0HighPtNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDT_VBF0HighPtNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDT_VBF0HighPtNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDT_VBF0HighPtNode*   fLeft;     // pointer to the left daughter node
   BDT_VBF0HighPtNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDT_VBF0HighPtNode::~BDT_VBF0HighPtNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDT_VBF0HighPtNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDT_VBF0HighPtNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT_VBF0HighPt : public IClassifierReader {

 public:

   // constructor
   ReadBDT_VBF0HighPt( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT_VBF0HighPt" ),
        fNvars( 17 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "mjj", "jjpt", "detajj", "dphijj", "ystar", "relbpt", "dphibjj", "balance", "j_c2_00[0]", "j_c2_00[1]", "j_qg[0]", "j_qg[1]", "dphivj1", "dphivj2", "ht", "isotropy", "D" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;
      fVmin[16] = 0;
      fVmax[16] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';
      fType[16] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT_VBF0HighPt() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[17];
   double fVmax[17];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[17];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDT_VBF0HighPtNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT_VBF0HighPt::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDT_VBF0HighPtNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDT_VBF0HighPtNode*)current->GetRight();
         else current=(BDT_VBF0HighPtNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT_VBF0HighPt::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.392961889224404);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.728064,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489863,-99) , 
4, 1.3353, 1, 0, 0.692781,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607469,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402753,-99) , 
0, 1257.89, 0, 0, 0.485444,-99) , 
8, 0.573214, 1, 0, 0.637357,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519153,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.298278,-99) , 
10, 0.559809, 0, 0, 0.445273,-99) , 
NN(
0, 
0, 
-1, 610.575, 0, -1, 0.278141,-99) , 
11, 0.798436, 0, 0, 0.367494,-99) , 
0, 863.898, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.273679);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.12649, 0, 1, 0.633084,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.397369,-99) , 
4, -1.38138, 0, 0, 0.60063,-99) , 
NN(
0, 
0, 
-1, 619.155, 0, -1, 0.404032,-99) , 
0, 857.718, 0, 0, 0.500341,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.196482);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.717078,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589485,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473743,-99) , 
13, 3.1265, 0, 0, 0.522983,-99) , 
0, 1654.97, 0, 0, 0.54458,-99) , 
NN(
0, 
0, 
-1, 0.0555255, 0, -1, 0.361342,-99) , 
10, 0.13645, 0, 0, 0.518024,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.221906);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617427,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477212,-99) , 
4, -0.908154, 0, 0, 0.579033,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401431,-99) , 
4, 1.56577, 1, 0, 0.558936,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415395,-99) , 
0, 553.918, 0, 0, 0.468932,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.343154,-99) , 
5, 1.3472, 0, 0, 0.421069,-99) , 
0, 619.155, 0, 0, 0.529557,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.165805);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.796895,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406581,-99) , 
11, 0.120861, 0, 0, 0.530367,-99) , 
0, 2239.52, 0, 0, 0.540704,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372504,-99) , 
10, 0.0777028, 0, 0, 0.522993,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.140881);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.745888,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44786,-99) , 
4, 0.631003, 1, 0, 0.509567,-99) , 
NN(
0, 
0, 
-1, 1.51185, 1, -1, 0.420065,-99) , 
0, 619.155, 0, 0, 0.489526,-99) , 
0, 2236.02, 0, 0, 0.499015,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.133298);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.717193,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54201,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439058,-99) , 
12, 2.26887, 1, 0, 0.519968,-99) , 
NN(
0, 
0, 
-1, 0.515147, 1, -1, 0.44629,-99) , 
10, 0.813544, 0, 0, 0.488787,-99) , 
0, 2239.52, 0, 0, 0.496968,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.0909795);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1442.47, 0, 1, 0.541938,-99) , 
NN(
0, 
0, 
-1, 0.0515395, 0, -1, 0.465515,-99) , 
9, 0.529219, 1, 0, 0.499872,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.0631637);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684894,-99) , 
NN(
NN(
0, 
0, 
-1, 0.950516, 0, 1, 0.565751,-99) , 
NN(
0, 
0, 
-1, -1.54, 0, -1, 0.486079,-99) , 
2, 0.766993, 1, 0, 0.496332,-99) , 
0, 2239.52, 0, 0, 0.502877,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.0900062);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.6113,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426652,-99) , 
14, 1062.97, 1, 0, 0.513528,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432132,-99) , 
4, -1.54, 0, 0, 0.504565,-99) , 
0, 1686.66, 0, 0, 0.514447,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.127091);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2149.12, 0, 1, 0.591796,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529329,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413106,-99) , 
10, 0.950414, 0, 0, 0.461331,-99) , 
2, 3.08491, 0, 0, 0.542646,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476069,-99) , 
15, 0.706332, 0, 0, 0.524291,-99) , 
NN(
0, 
0, 
-1, 1.19766, 1, -1, 0.460834,-99) , 
2, 1.50823, 1, 0, 0.480042,-99) , 
0, 1065.64, 0, 0, 0.499479,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.101751);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.94435, 0, 1, 0.589809,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576244,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487583,-99) , 
7, 34.0917, 1, 0, 0.506839,-99) , 
2, 3.1347, 0, 0, 0.536286,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546714,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479349,-99) , 
12, 0.399962, 1, 0, 0.49727,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417663,-99) , 
4, 1.26633, 1, 0, 0.484204,-99) , 
15, 0.771165, 1, 0, 0.508528,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.0648257);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2239.52, 0, 1, 0.523917,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437913,-99) , 
8, 0.61199, 1, 0, 0.517004,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.0710229);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.645142,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474308,-99) , 
4, -0.666199, 0, 0, 0.504955,-99) , 
0, 2239.52, 0, 0, 0.509414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423455,-99) , 
4, 1.86352, 1, 0, 0.503419,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0777694);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564818,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512471,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403334,-99) , 
14, 1082.06, 1, 0, 0.50234,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514962,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400991,-99) , 
5, 1.79879, 0, 0, 0.447887,-99) , 
4, 1.09816, 1, 0, 0.491814,-99) , 
8, 0.43017, 1, 0, 0.498993,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0825087);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598711,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518713,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452665,-99) , 
7, 104.921, 1, 0, 0.499851,-99) , 
NN(
0, 
0, 
-1, 440.191, 0, -1, 0.461392,-99) , 
15, 0.808352, 1, 0, 0.482479,-99) , 
0, 2239.52, 0, 0, 0.486223,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0856997);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607484,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561092,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48283,-99) , 
12, 0.732622, 1, 0, 0.502189,-99) , 
0, 1433.37, 0, 0, 0.520804,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547263,-99) , 
NN(
0, 
0, 
-1, 0.0555255, 0, -1, 0.468835,-99) , 
7, 19.2404, 1, 0, 0.477094,-99) , 
8, 0.501686, 1, 0, 0.49031,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0689581);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.658237, 1, 1, 0.522242,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441683,-99) , 
0, 867.094, 1, 0, 0.482842,-99) , 
9, 0.563033, 1, 0, 0.508737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426839,-99) , 
0, 530.369, 0, 0, 0.504188,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0537975);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546217,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507129,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471499,-99) , 
4, 0.328004, 1, 0, 0.49276,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426688,-99) , 
10, 0.044318, 0, 0, 0.488085,-99) , 
8, 0.43017, 1, 0, 0.493766,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0351716);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603102,-99) , 
NN(
0, 
0, 
-1, 0.0513784, 0, -1, 0.49189,-99) , 
0, 2239.52, 0, 0, 0.49527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426844,-99) , 
4, -1.94075, 0, 0, 0.491247,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0601796);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483332,-99) , 
0, 695.38, 0, 0, 0.508436,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432386,-99) , 
11, 0.0481844, 0, 0, 0.503771,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435585,-99) , 
4, -1.94075, 0, 0, 0.499772,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0504314);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.950516, 0, 1, 0.539922,-99) , 
NN(
NN(
0, 
0, 
-1, 1823.23, 0, 1, 0.510136,-99) , 
NN(
0, 
0, 
-1, -2.74881, 0, -1, 0.474668,-99) , 
13, 2.94481, 0, 0, 0.491155,-99) , 
2, 0.765261, 1, 0, 0.497308,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0621674);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 4.10531, 0, 1, 0.512932,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518773,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417001,-99) , 
13, 2.7596, 0, 0, 0.467802,-99) , 
3, -2.75008, 0, 0, 0.50469,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52068,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447855,-99) , 
4, 0.4305, 1, 0, 0.494091,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435904,-99) , 
16, 0.00237015, 0, 0, 0.471342,-99) , 
5, 1.23312, 0, 0, 0.496606,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.052025);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530231,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540733,-99) , 
NN(
0, 
0, 
-1, 0.0555255, 0, -1, 0.480311,-99) , 
6, 3.12384, 0, 0, 0.483328,-99) , 
8, 0.43017, 1, 0, 0.487892,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0499665);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573748,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499397,-99) , 
4, -0.158797, 0, 0, 0.54001,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440345,-99) , 
10, 0.998906, 1, 0, 0.498997,-99) , 
6, -3.08578, 1, 0, 0.505175,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524035,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504976,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446581,-99) , 
9, 0.547021, 1, 0, 0.462154,-99) , 
7, 112.023, 0, 0, 0.476596,-99) , 
11, 0.404276, 0, 0, 0.497432,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0459991);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588918,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503387,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445085,-99) , 
2, 4.29616, 1, 0, 0.497784,-99) , 
0, 2149.19, 0, 0, 0.501638,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522823,-99) , 
NN(
0, 
0, 
-1, 0.0555255, 0, -1, 0.467903,-99) , 
6, -3.08511, 1, 0, 0.475631,-99) , 
8, 0.559886, 1, 0, 0.491518,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0406561);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571525,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502383,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478778,-99) , 
14, 519.842, 1, 0, 0.489413,-99) , 
0, 2239.52, 0, 0, 0.491865,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443764,-99) , 
4, -1.94075, 0, 0, 0.489048,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0689194);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.950516, 0, 1, 0.528384,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466232,-99) , 
4, -0.475172, 0, 0, 0.49279,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501568,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417623,-99) , 
13, 2.58753, 1, 0, 0.452618,-99) , 
4, 1.1196, 1, 0, 0.484914,-99) , 
2, 0.765261, 1, 0, 0.490403,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0598134);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558489,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501792,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469281,-99) , 
2, 3.18139, 1, 0, 0.491537,-99) , 
0, 1668.94, 0, 0, 0.497164,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538564,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47569,-99) , 
10, 0.774691, 1, 0, 0.499718,-99) , 
NN(
0, 
0, 
-1, 1.44227, 0, -1, 0.451485,-99) , 
16, 0.0146087, 0, 0, 0.473906,-99) , 
4, 0.331381, 1, 0, 0.487828,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0548605);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54123,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483462,-99) , 
0, 2072.68, 0, 0, 0.486568,-99) , 
1, 432.682, 0, 0, 0.491116,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441204,-99) , 
14, 1195.18, 1, 0, 0.488024,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0369927);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509342,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471666,-99) , 
10, 0.998821, 1, 0, 0.505585,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462596,-99) , 
0, 543.395, 0, 0, 0.50193,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455048,-99) , 
14, 1195.18, 1, 0, 0.49903,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0538263);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.529047, 1, 1, 0.525345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471669,-99) , 
14, 387.015, 0, 0, 0.510247,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481822,-99) , 
8, 0.580807, 0, 0, 0.491505,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450161,-99) , 
10, 0.0555255, 0, 0, 0.487015,-99) , 
8, 0.501686, 1, 0, 0.494015,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0317943);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496378,-99) , 
0, 1110.66, 0, 0, 0.503464,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437072,-99) , 
2, 2.54454, 1, 0, 0.471159,-99) , 
13, 0.953248, 0, 0, 0.499584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454803,-99) , 
9, 0.611595, 1, 0, 0.496855,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0282891);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543333,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504318,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457114,-99) , 
7, 204.57, 1, 0, 0.500776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45615,-99) , 
14, 295.429, 0, 0, 0.497603,-99) , 
5, 0.938977, 1, 0, 0.50029,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0366235);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519454,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493609,-99) , 
15, 0.695489, 1, 0, 0.501972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460906,-99) , 
9, 0.606972, 1, 0, 0.498754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464815,-99) , 
13, 0.835697, 0, 0, 0.495098,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0508704);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544183,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510978,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461343,-99) , 
9, 0.597222, 1, 0, 0.504486,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468373,-99) , 
11, 0.965038, 0, 0, 0.482869,-99) , 
12, 1.71139, 1, 0, 0.496684,-99) , 
5, 0.938977, 1, 0, 0.499475,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0551546);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 32.5879, 1, 1, 0.528459,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507074,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478114,-99) , 
11, 0.848025, 1, 0, 0.493557,-99) , 
6, -3.0653, 1, 0, 0.500707,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534946,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472535,-99) , 
7, 77.5405, 0, 0, 0.502207,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.439602,-99) , 
2, 1.36333, 1, 0, 0.476012,-99) , 
5, 2.44207, 1, 0, 0.495075,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0455758);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.512056, 0, 1, 0.532694,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475088,-99) , 
7, 45.3903, 0, 0, 0.494045,-99) , 
5, 1.12492, 1, 0, 0.500572,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503623,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450278,-99) , 
5, 1.23298, 0, 0, 0.490914,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433911,-99) , 
0, 1234.47, 1, 0, 0.480466,-99) , 
8, 0.56838, 1, 0, 0.493829,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0671327);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573083,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515966,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46791,-99) , 
4, 0.627136, 1, 0, 0.500807,-99) , 
0, 1404.63, 0, 0, 0.510525,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479496,-99) , 
0, 700.768, 0, 0, 0.4976,-99) , 
NN(
0, 
0, 
-1, 1002.64, 0, -1, 0.468495,-99) , 
0, 856.984, 1, 0, 0.483559,-99) , 
7, 32.8291, 1, 0, 0.490179,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.050367);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1433.59, 0, 1, 0.516251,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456387,-99) , 
0, 851.338, 1, 0, 0.48851,-99) , 
9, 0.548794, 1, 0, 0.503604,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504617,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457839,-99) , 
4, -1.02606, 0, 0, 0.494129,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462435,-99) , 
14, 738.922, 1, 0, 0.4853,-99) , 
8, 0.560865, 1, 0, 0.496595,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0733387);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579368,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492155,-99) , 
6, -3.00947, 0, 0, 0.542993,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543312,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454324,-99) , 
6, -2.91801, 1, 0, 0.478365,-99) , 
13, 3.00368, 0, 0, 0.505145,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507529,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453654,-99) , 
10, 0.194412, 0, 0, 0.497469,-99) , 
NN(
0, 
0, 
-1, 0.00780048, 0, -1, 0.468809,-99) , 
13, 3.00825, 1, 0, 0.484535,-99) , 
0, 1017.52, 0, 0, 0.491485,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0558465);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602452,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509346,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469297,-99) , 
11, 0.402438, 0, 0, 0.499723,-99) , 
0, 1823.23, 0, 0, 0.505879,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522821,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517377,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471894,-99) , 
1, 430.62, 0, 0, 0.477505,-99) , 
3, 2.71545, 0, 0, 0.484261,-99) , 
13, 2.94481, 0, 0, 0.494124,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0601395);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.91782, 1, 1, 0.530247,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517577,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450737,-99) , 
11, 0.793093, 0, 0, 0.483105,-99) , 
4, 0.216949, 1, 0, 0.508598,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523429,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485053,-99) , 
1, 217.188, 1, 0, 0.497616,-99) , 
NN(
0, 
0, 
-1, 3.19814, 1, -1, 0.473395,-99) , 
4, -0.260843, 0, 0, 0.487211,-99) , 
0, 1017.52, 0, 0, 0.494409,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0223578);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533608,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539612,-99) , 
NN(
0, 
0, 
-1, 3.08126, 1, -1, 0.493738,-99) , 
6, 3.12496, 0, 0, 0.495862,-99) , 
5, 0.938977, 1, 0, 0.49807,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0339034);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548285,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453317,-99) , 
3, -2.75033, 0, 0, 0.5027,-99) , 
3, -2.95583, 1, 0, 0.505507,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478137,-99) , 
13, 0.835697, 0, 0, 0.502562,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0379296);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551388,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476391,-99) , 
0, 679.808, 0, 0, 0.516017,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502558,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44568,-99) , 
4, 1.81616, 1, 0, 0.497899,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437205,-99) , 
14, 965.522, 1, 0, 0.49323,-99) , 
2, 1.04244, 1, 0, 0.497165,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0452337);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485943,-99) , 
0, 679.808, 0, 0, 0.515538,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461558,-99) , 
14, 650.264, 1, 0, 0.491398,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447581,-99) , 
4, -1.58635, 0, 0, 0.486644,-99) , 
2, 1.04244, 1, 0, 0.49163,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0503206);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554204,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496166,-99) , 
11, 0.990095, 0, 0, 0.514965,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541856,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483678,-99) , 
8, 0.421778, 1, 0, 0.487063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443889,-99) , 
10, 0.998975, 1, 0, 0.483326,-99) , 
2, 1.04244, 1, 0, 0.488783,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0772472);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600475,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468778,-99) , 
4, 0.930919, 0, 0, 0.493013,-99) , 
4, -0.970467, 1, 0, 0.514046,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511344,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460644,-99) , 
4, 1.23361, 1, 0, 0.500011,-99) , 
NN(
0, 
0, 
-1, 0.702876, 1, -1, 0.451298,-99) , 
4, -1.31469, 0, 0, 0.491816,-99) , 
2, 1.80263, 1, 0, 0.49893,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0605231);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581802,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540792,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481882,-99) , 
4, 0.587256, 0, 0, 0.502981,-99) , 
4, -0.970467, 1, 0, 0.518346,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493663,-99) , 
0, 1830.3, 0, 0, 0.500465,-99) , 
NN(
0, 
0, 
-1, -2.92089, 1, -1, 0.473828,-99) , 
15, 0.770155, 1, 0, 0.486181,-99) , 
2, 1.80263, 1, 0, 0.49646,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0373118);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48262,-99) , 
2, 2.53281, 1, 0, 0.527097,-99) , 
NN(
NN(
0, 
0, 
-1, 0.000260984, 1, 1, 0.506399,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469699,-99) , 
4, -0.851495, 0, 0, 0.502086,-99) , 
4, -1.23712, 1, 0, 0.50618,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0422814);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.583468,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488392,-99) , 
14, 547.998, 0, 0, 0.528977,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56721,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488912,-99) , 
15, 0.893399, 1, 0, 0.52462,-99) , 
NN(
0, 
0, 
-1, 4.43109, 1, -1, 0.490669,-99) , 
16, 0.000561768, 1, 0, 0.494946,-99) , 
4, -1.23607, 1, 0, 0.50052,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0433277);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578627,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498592,-99) , 
2, 2.53281, 1, 0, 0.530628,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545785,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476073,-99) , 
5, 1.9262, 1, 0, 0.521722,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503774,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.454366,-99) , 
2, 4.21744, 1, 0, 0.49885,-99) , 
7, 32.8291, 1, 0, 0.504372,-99) , 
4, -1.23712, 1, 0, 0.50866,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0412065);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 547.998, 0, 1, 0.532847,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543701,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49035,-99) , 
4, 0.393055, 1, 0, 0.518435,-99) , 
NN(
0, 
0, 
-1, 46.3812, 0, -1, 0.490179,-99) , 
7, 32.8291, 1, 0, 0.496995,-99) , 
4, -1.23712, 1, 0, 0.502847,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0691832);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578361,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526256,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491103,-99) , 
1, 269.642, 1, 0, 0.509816,-99) , 
9, 0.472332, 1, 0, 0.516754,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553882,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490962,-99) , 
0, 909.982, 1, 0, 0.529034,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525547,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465131,-99) , 
0, 949.912, 0, 0, 0.486607,-99) , 
10, 0.521412, 1, 0, 0.499355,-99) , 
11, 0.808257, 1, 0, 0.507642,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0503125);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0974101, 1, 1, 0.517452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477125,-99) , 
0, 566.199, 0, 0, 0.512801,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524861,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507025,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441561,-99) , 
11, 0.814384, 1, 0, 0.471125,-99) , 
10, 0.427841, 1, 0, 0.487877,-99) , 
1, 195.898, 0, 0, 0.507653,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0456682);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546868,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499656,-99) , 
0, 851.574, 1, 0, 0.530622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488089,-99) , 
7, 48.5871, 0, 0, 0.516816,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529327,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489221,-99) , 
10, 0.842749, 0, 0, 0.511583,-99) , 
NN(
0, 
0, 
-1, 2.56458, 0, -1, 0.484838,-99) , 
6, -2.98468, 1, 0, 0.493277,-99) , 
2, 1.50823, 1, 0, 0.499347,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0361141);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498256,-99) , 
10, 0.918215, 0, 0, 0.523445,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493737,-99) , 
14, 519.842, 1, 0, 0.505035,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463239,-99) , 
10, 0.998986, 1, 0, 0.501451,-99) , 
2, 1.04059, 1, 0, 0.505216,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0468613);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.548871, 0, 1, 0.539571,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530021,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480294,-99) , 
13, 2.31494, 1, 0, 0.501466,-99) , 
15, 0.789374, 0, 0, 0.520329,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566768,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499525,-99) , 
16, 0.0240673, 1, 0, 0.515201,-99) , 
NN(
0, 
0, 
-1, 0.00429558, 1, -1, 0.487576,-99) , 
16, 0.0146299, 0, 0, 0.498256,-99) , 
2, 1.80263, 1, 0, 0.505299,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.03114);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561127,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499777,-99) , 
15, 0.893516, 1, 0, 0.541923,-99) , 
NN(
0, 
0, 
-1, 3.18146, 0, 1, 0.506395,-99) , 
1, 362.077, 0, 0, 0.512393,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478541,-99) , 
14, 1191.18, 1, 0, 0.510311,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0442895);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0210821, 0, 1, 0.546895,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479231,-99) , 
14, 954.147, 1, 0, 0.525896,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543117,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491075,-99) , 
16, 0.133206, 0, 0, 0.495185,-99) , 
5, 3.27669, 0, 0, 0.499221,-99) , 
1, 362.077, 0, 0, 0.504262,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0324056);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538847,-99) , 
NN(
NN(
0, 
0, 
-1, 2.5778, 1, 1, 0.51036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472722,-99) , 
3, -2.74867, 0, 0, 0.507119,-99) , 
3, -2.95583, 1, 0, 0.509094,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0202024);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525646,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499233,-99) , 
5, 1.01941, 1, 0, 0.50279,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457887,-99) , 
2, 4.43109, 1, 0, 0.499901,-99) , 
16, 0.000262478, 1, 0, 0.502305,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0327902);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534214,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538232,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508668,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484818,-99) , 
15, 0.853692, 1, 0, 0.501617,-99) , 
3, -2.96049, 1, 0, 0.503851,-99) , 
1, 485.677, 0, 0, 0.50576,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.035802);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.72656, 1, 1, 0.532822,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467494,-99) , 
5, 2.78789, 1, 0, 0.515863,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538834,-99) , 
NN(
0, 
0, 
-1, 4.29616, 1, -1, 0.493509,-99) , 
0, 1668.94, 0, 0, 0.497387,-99) , 
12, 0.624025, 1, 0, 0.501836,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0375893);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.0212, 1, 1, 0.512511,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52273,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474376,-99) , 
12, 1.55374, 0, 0, 0.491332,-99) , 
1, 195.898, 0, 0, 0.508207,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470011,-99) , 
2, 4.82608, 1, 0, 0.506459,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0219451);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540766,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456347,-99) , 
7, 15.3394, 0, 0, 0.500229,-99) , 
6, 3.12559, 0, 0, 0.50211,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465831,-99) , 
15, 0.380273, 0, 0, 0.500293,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0362064);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471859,-99) , 
7, 55.2934, 0, 0, 0.513342,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573964,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494123,-99) , 
0, 2072.66, 0, 0, 0.496526,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458449,-99) , 
14, 1079.42, 1, 0, 0.493115,-99) , 
4, 1.35183, 0, 0, 0.49604,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0386267);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550497,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485049,-99) , 
14, 478.534, 0, 0, 0.519915,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510409,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489039,-99) , 
5, 2.09191, 1, 0, 0.503174,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463392,-99) , 
8, 0.61226, 1, 0, 0.500068,-99) , 
4, -1.23712, 1, 0, 0.5033,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.032887);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588087,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53756,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499553,-99) , 
4, 1.21379, 0, 0, 0.505302,-99) , 
2, 3.98406, 0, 0, 0.509229,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527896,-99) , 
NN(
0, 
0, 
-1, 42.3137, 0, -1, 0.483231,-99) , 
7, 23.5502, 1, 0, 0.491018,-99) , 
5, 1.53825, 0, 0, 0.501435,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.045081);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 3.98406, 0, 1, 0.51433,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5356,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490228,-99) , 
5, 1.14451, 1, 0, 0.509325,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51162,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457924,-99) , 
2, 3.20891, 1, 0, 0.478728,-99) , 
4, 0.26416, 1, 0, 0.496386,-99) , 
5, 1.53825, 0, 0, 0.506652,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.035135);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481063,-99) , 
7, 40.1774, 0, 0, 0.52017,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497951,-99) , 
2, 3.19968, 1, 0, 0.507334,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501512,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470696,-99) , 
4, -0.187915, 0, 0, 0.490642,-99) , 
2, 2.97649, 0, 0, 0.497403,-99) , 
4, -1.23712, 1, 0, 0.50111,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0507176);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.91782, 1, 1, 0.528697,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456137,-99) , 
0, 881.386, 1, 0, 0.50072,-99) , 
0, 1024.48, 0, 0, 0.50961,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543195,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474081,-99) , 
0, 938.369, 1, 0, 0.512259,-99) , 
NN(
0, 
0, 
-1, -0.935207, 0, -1, 0.482482,-99) , 
3, -2.24539, 1, 0, 0.490471,-99) , 
4, 0.224327, 1, 0, 0.501287,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0530715);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.5292, 0, 1, 0.522594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473097,-99) , 
4, -1.09644, 0, 0, 0.511031,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535392,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520206,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481107,-99) , 
4, 1.37241, 0, 0, 0.486534,-99) , 
4, -1.3209, 1, 0, 0.492838,-99) , 
2, 3.10305, 0, 0, 0.499742,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0276018);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522031,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51422,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494397,-99) , 
0, 989.016, 0, 0, 0.501589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467418,-99) , 
4, 1.86352, 1, 0, 0.499125,-99) , 
2, 0.571302, 1, 0, 0.5012,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0250154);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548386,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505504,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461151,-99) , 
2, 4.29554, 1, 0, 0.50275,-99) , 
0, 1654.97, 0, 0, 0.504574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.467604,-99) , 
0, 1965.55, 1, 0, 0.502634,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0209243);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526065,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526153,-99) , 
NN(
0, 
0, 
-1, 3.08126, 1, -1, 0.493738,-99) , 
6, 3.117, 0, 0, 0.495986,-99) , 
5, 0.938977, 1, 0, 0.497744,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0313416);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.27207, 0, 1, 0.512331,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506372,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477567,-99) , 
16, 0.00432141, 1, 0, 0.495445,-99) , 
16, 0.0168012, 0, 0, 0.503119,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474544,-99) , 
15, 0.379354, 0, 0, 0.501691,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.023288);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516316,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496282,-99) , 
9, 0.582158, 0, 0, 0.499334,-99) , 
NN(
0, 
0, 
-1, 0.00614193, 0, -1, 0.47188,-99) , 
11, 0.302941, 0, 0, 0.495678,-99) , 
11, 0.0974101, 1, 0, 0.497723,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0244053);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537742,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503658,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475491,-99) , 
11, 0.302941, 0, 0, 0.500406,-99) , 
9, 0.597457, 0, 0, 0.503631,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468929,-99) , 
11, 0.0481844, 0, 0, 0.501503,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0183051);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54595,-99) , 
NN(
0, 
0, 
-1, 2.47107, 1, -1, 0.495997,-99) , 
5, 3.18374, 0, 0, 0.498884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474033,-99) , 
14, 1191.18, 1, 0, 0.497359,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.023362);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541409,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504358,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475762,-99) , 
5, 2.47107, 1, 0, 0.500582,-99) , 
5, 3.18374, 0, 0, 0.50294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47861,-99) , 
14, 1191.18, 1, 0, 0.501448,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.021135);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530074,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502784,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482931,-99) , 
9, 0.490024, 0, 0, 0.497535,-99) , 
7, 19.1252, 1, 0, 0.499169,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474569,-99) , 
7, 13.3506, 0, 0, 0.49769,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0265819);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541095,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49255,-99) , 
9, 0.459972, 0, 0, 0.513956,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523678,-99) , 
NN(
0, 
0, 
-1, 0.0513714, 0, -1, 0.491234,-99) , 
9, 0.424118, 1, 0, 0.493332,-99) , 
11, 0.997596, 0, 0, 0.495539,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0208878);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53171,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534543,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496775,-99) , 
3, -2.95596, 1, 0, 0.499055,-99) , 
9, 0.594849, 0, 0, 0.502336,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477292,-99) , 
11, 0.0481844, 0, 0, 0.500801,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0241188);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539981,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511872,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496707,-99) , 
16, 0.0137066, 0, 0, 0.504145,-99) , 
11, 0.105176, 1, 0, 0.506173,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479061,-99) , 
9, 0.611595, 1, 0, 0.504515,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0222187);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531438,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544319,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496329,-99) , 
6, -2.97677, 1, 0, 0.501625,-99) , 
0, 2158.06, 0, 0, 0.503027,-99) , 
3, 2.97367, 0, 0, 0.504671,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0304902);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.559924,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498053,-99) , 
1, 205.016, 1, 0, 0.507439,-99) , 
5, 2.89791, 0, 0, 0.513329,-99) , 
NN(
NN(
0, 
0, 
-1, 1426.57, 0, 1, 0.50561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46482,-99) , 
5, 2.95007, 1, 0, 0.499813,-99) , 
6, 2.56488, 0, 0, 0.506063,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0435332);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533698,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493409,-99) , 
7, 32.0069, 0, 0, 0.523499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4879,-99) , 
10, 0.996647, 1, 0, 0.516412,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532641,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500706,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47116,-99) , 
16, 0.022548, 1, 0, 0.489965,-99) , 
16, 0.166921, 0, 0, 0.494358,-99) , 
6, 2.56488, 0, 0, 0.504555,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0475099);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547498,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478627,-99) , 
2, 3.67095, 1, 0, 0.508929,-99) , 
0, 1433.59, 0, 0, 0.5143,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531888,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489266,-99) , 
10, 0.983685, 0, 0, 0.503511,-99) , 
NN(
0, 
0, 
-1, 612.576, 1, -1, 0.478413,-99) , 
2, 2.53821, 1, 0, 0.490574,-99) , 
6, 2.56488, 0, 0, 0.501541,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.032674);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.520532, 1, 1, 0.512589,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476504,-99) , 
15, 0.711287, 0, 0, 0.495861,-99) , 
14, 521.487, 1, 0, 0.503407,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4746,-99) , 
0, 530.369, 0, 0, 0.501798,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.031409);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566603,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496249,-99) , 
5, 3.0845, 0, 0, 0.499531,-99) , 
0, 2046.01, 0, 0, 0.502044,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533685,-99) , 
NN(
0, 
0, 
-1, 0.585023, 1, -1, 0.477048,-99) , 
6, 3.09859, 0, 0, 0.486256,-99) , 
15, 0.875885, 1, 0, 0.497665,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0512904);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518851,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482505,-99) , 
6, 3.08072, 1, 0, 0.513313,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505557,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461028,-99) , 
0, 749.774, 0, 0, 0.487976,-99) , 
3, 2.33658, 1, 0, 0.50759,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549939,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489351,-99) , 
7, 40.1171, 1, 0, 0.512271,-99) , 
NN(
0, 
0, 
-1, 0.368524, 1, -1, 0.465398,-99) , 
3, -0.196106, 0, 0, 0.490443,-99) , 
15, 0.888465, 1, 0, 0.503426,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0375788);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54748,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527594,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465881,-99) , 
1, 281.074, 0, 0, 0.496076,-99) , 
10, 0.721211, 1, 0, 0.514131,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531038,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495177,-99) , 
6, 2.94328, 0, 0, 0.499057,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456072,-99) , 
6, 3.025, 1, 0, 0.495918,-99) , 
6, 3.06088, 0, 0, 0.499602,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0180689);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 1654.97, 0, 1, 0.506589,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475356,-99) , 
0, 1965.55, 1, 0, 0.504965,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0227408);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521053,-99) , 
NN(
NN(
0, 
0, 
-1, 0.538458, 0, 1, 0.505925,-99) , 
NN(
0, 
0, 
-1, 0.563607, 0, -1, 0.488956,-99) , 
9, 0.548779, 1, 0, 0.498593,-99) , 
7, 167.51, 0, 0, 0.500918,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.017846);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518867,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534374,-99) , 
NN(
0, 
0, 
-1, 0.938939, 1, -1, 0.495428,-99) , 
12, 0.16501, 1, 0, 0.497529,-99) , 
11, 0.0974101, 1, 0, 0.49964,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0419107);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.511518, 1, 1, 0.51129,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519489,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462377,-99) , 
1, 224.247, 1, 0, 0.483194,-99) , 
4, 1.11942, 1, 0, 0.5058,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517728,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457823,-99) , 
1, 291.447, 1, 0, 0.47908,-99) , 
4, 0.609073, 0, 0, 0.491008,-99) , 
14, 813.254, 1, 0, 0.50279,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0270937);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527948,-99) , 
NN(
0, 
0, 
-1, 544.807, 0, -1, 0.495274,-99) , 
7, 133.311, 0, 0, 0.499339,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515135,-99) , 
NN(
0, 
0, 
-1, 0.755852, 0, -1, 0.469974,-99) , 
10, 0.427841, 1, 0, 0.484059,-99) , 
1, 195.898, 0, 0, 0.49618,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0278845);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0974101, 1, 1, 0.507572,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480587,-99) , 
0, 566.199, 0, 0, 0.504436,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509868,-99) , 
NN(
0, 
0, 
-1, 1.92823, 1, -1, 0.469136,-99) , 
14, 447.886, 1, 0, 0.486604,-99) , 
1, 195.898, 0, 0, 0.500751,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT_VBF0HighPt::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT_VBF0HighPt::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
